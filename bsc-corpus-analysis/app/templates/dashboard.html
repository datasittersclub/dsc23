<!DOCTYPE html>
<html>
<head>
    <title>üïπÔ∏è BSC Story Analysis Dashboard</title>
    <link rel="stylesheet" href="/static/style.css">
    <style>
        body {
            padding: 2em;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 2em 0;
        }
        
        .card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 1.5em;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .controls-section {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffff;
            border-radius: 8px;
            padding: 1.5em;
            margin: 1em 0;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0.5em 0;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0.5em 0;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 1em;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }
        
        .control-row label {
            min-width: 120px;
            color: #00ffff;
        }
        
        .control-row select, .control-row button {
            margin-left: 10px;
        }
        
        .card-title {
            font-family: 'Press Start 2P', cursive;
            color: #ff69b4;
            font-size: 14px;
            margin-bottom: 1em;
            text-shadow: 0 0 10px #ff69b4;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .full-width {
            grid-column: 1 / -1;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .stat-card {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #ff69b4;
            display: block;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #00ffff;
            text-transform: uppercase;
        }
        
        .legend {
            margin-top: 1em;
            font-size: 11px;
        }
        
        .legend-item {
            display: inline-block;
            margin: 0 10px 5px 0;
        }
        
        .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
        }
        
        .error {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid #ff0000;
            color: #ff6666;
            padding: 1em;
            border-radius: 5px;
            margin: 1em 0;
        }
        
        select, input, button {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'VT323', monospace;
            font-size: 14px;
        }
        
        button {
            background: rgba(0, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        .chart-container {
            position: relative;
            min-height: 300px;
        }
        
        /* Fullscreen functionality */
        .fullscreen-btn {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 3px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 12px;
            transition: all 0.3s ease;
            z-index: 1000;
            flex-shrink: 0;
        }
        
        .fullscreen-btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9999;
            display: none;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .fullscreen-content {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .close-fullscreen {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 107, 180, 0.3);
            border: 1px solid #ff69b4;
            color: #ff69b4;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 14px;
            z-index: 10000;
        }
        
        .close-fullscreen:hover {
            background: rgba(255, 107, 180, 0.5);
            box-shadow: 0 0 10px rgba(255, 107, 180, 0.3);
        }
        
        /* Scene details styling */
        .scene-info {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .scene-header {
            font-size: 16px;
            font-weight: bold;
            color: #ff69b4;
            margin-bottom: 10px;
        }
        
        .scene-meta {
            font-size: 12px;
            color: #00ffff;
            margin-bottom: 10px;
        }
        
        .goals-conflicts {
            margin: 10px 0;
        }
        
        .goals-conflicts h4 {
            color: #ff69b4;
            margin: 5px 0;
        }
        
        .goal-item, .conflict-item {
            background: rgba(255, 107, 180, 0.1);
            border-left: 3px solid #ff69b4;
            padding: 8px;
            margin: 5px 0;
            font-size: 12px;
        }
        
        .evidence-text {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #00ffff;
            border-radius: 3px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'VT323', monospace;
            font-size: 12px;
            color: #00ffff;
            white-space: pre-wrap;
        }
        
        /* Navigation styles */
        header {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 1em;
            margin-bottom: 2em;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        nav {
            margin-top: 1em;
            text-align: center;
        }
        
        nav a {
            color: #00ffff;
            text-decoration: none;
            margin: 0 15px;
            padding: 8px 16px;
            border: 1px solid #00ffff;
            border-radius: 4px;
            background: rgba(0, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        nav a:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        
        nav a.active {
            background: rgba(255, 107, 180, 0.3);
            border-color: #ff69b4;
            color: #ff69b4;
        }
    </style>
</head>
<body>
    <header>
        <h1>üïπÔ∏è Baby-Sitters Club Story Analysis Dashboard</h1>
        <nav>
            <a href="/">üè† Home</a>
            <a href="/api_keys">üîë Configuration</a>
            <a href="/visualization" class="active">üìä Visualization</a>
        </nav>
    </header>
    {% if error %}
        <div class="error">{{ error }}</div>
    {% endif %}
    
    <div class="controls-section">
        <h2>üìä Analysis Results</h2>
        <div class="control-row">
            <label for="result-selector">Choose Results:</label>
            <select id="result-selector"></select>
            <button id="load-result">Load Analysis</button>
        </div>
        {% if auto_load_result %}
        <script>
            window.addEventListener('DOMContentLoaded', function() {
                document.getElementById('result-selector').value = '{{ auto_load_result }}';
                document.getElementById('load-result').click();
            });
        </script>
        {% endif %}
    </div>

    <div class="dashboard">
        <div class="card">
            <div class="card-title">
                <span>üéØ Goal Categories Distribution</span>
                <button class="fullscreen-btn" onclick="openFullscreen('goals-chart')">üîç</button>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Sort by:</label>
                    <select id="goal-sort">
                        <option value="count">Count</option>
                        <option value="alphabetical">Alphabetical</option>
                    </select>
                </div>
            </div>
            <div id="goals-chart" class="chart-container">
            </div>
            <div class="legend" id="goals-legend"></div>
        </div>
        <div class="card">
            <div class="card-title">
                <span>üìè Scene Length Distribution</span>
                <button class="fullscreen-btn" onclick="openFullscreen('length-chart')">üîç</button>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Bins:</label>
                    <input type="range" id="bins-slider" min="5" max="20" value="10">
                    <span id="bins-value">10</span>
                </div>
            </div>
            <div id="length-chart" class="chart-container">
            </div>
        </div>
        <div class="card">
            <div class="card-title">
                <span>‚ö° Goals vs Conflicts by Scene</span>
                <button class="fullscreen-btn" onclick="openFullscreen('scatter-chart')">üîç</button>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Size by:</label>
                    <select id="scatter-size">
                        <option value="length">Scene Length</option>
                        <option value="constant">Equal Size</option>
                    </select>
                </div>
            </div>
            <div id="scatter-chart" class="chart-container">
            </div>
        </div>
        <div class="card">
            <div class="card-title">
                <span>üï∏Ô∏è Character Conflict Network</span>
                <button class="fullscreen-btn" onclick="openFullscreen('conflict-network-chart')">üîç</button>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Filter by character:</label>
                    <select id="character-filter">
                        <option value="all">All Characters</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Conflict threshold:</label>
                    <input type="range" id="conflict-threshold" min="1" max="10" value="1">
                    <span id="threshold-value">1</span>
                </div>
            </div>
            <div id="conflict-network-chart" class="chart-container">
            </div>
        </div>
        <div class="card">
            <div class="card-title">
                <span>üï∏Ô∏è Character & Goal Network</span>
                <button class="fullscreen-btn" onclick="openFullscreen('goal-network-chart')">üîç</button>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>Filter by category:</label>
                    <select id="goal-filter">
                        <option value="all">All Categories</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Force strength:</label>
                    <input type="range" id="goal-force-slider" min="50" max="300" value="150">
                    <span id="goal-force-value">150</span>
                </div>
            </div>
            <div id="goal-network-chart" class="chart-container">
            </div>
        </div>
        <div class="card full-width">
            <div class="card-title">üîç Scene Details</div>
            <div class="controls">
                <div class="control-group">
                    <label>Select scene:</label>
                    <select id="scene-selector">
                        <option value="">Choose a scene...</option>
                    </select>
                </div>
            </div>
            <div id="scene-details"></div>
        </div>
        <div class="card full-width">
            <div class="card-title">üìä Dataset Overview</div>
            <div class="stats-grid" id="stats-container"></div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <!-- Fullscreen overlay template -->
    <div class="fullscreen-overlay" id="fullscreen-overlay">
        <div class="fullscreen-content" id="fullscreen-content">
            <button class="close-fullscreen" onclick="closeFullscreen()">‚úï Close</button>
            <div id="fullscreen-chart-container"></div>
        </div>
    </div>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        let data = null;
        let tooltip = d3.select("#tooltip");
        let availableResults = [];

        // Fullscreen functionality
        function openFullscreen(chartId) {
            const overlay = document.getElementById('fullscreen-overlay');
            const container = document.getElementById('fullscreen-chart-container');
            
            // Clear previous content
            container.innerHTML = '';
            
            // Create fullscreen chart container
            const fullscreenChart = document.createElement('div');
            fullscreenChart.id = chartId + '-fullscreen';
            fullscreenChart.style.width = '100%';
            fullscreenChart.style.height = '80vh';
            container.appendChild(fullscreenChart);
            
            // Show overlay
            overlay.style.display = 'block';
            
            // Re-render the chart in fullscreen
            setTimeout(() => {
                redrawChart(chartId + '-fullscreen', chartId);
            }, 100);
        }
        
        function closeFullscreen() {
            const overlay = document.getElementById('fullscreen-overlay');
            overlay.style.display = 'none';
        }
        
        function redrawChart(fullscreenId, originalId) {
            const container = document.getElementById(fullscreenId);
            if (!container || !data) return;
            
            // Clear existing content
            d3.select('#' + fullscreenId).selectAll('*').remove();
            
            // Get chart dimensions for fullscreen
            const width = window.innerWidth - 100;
            const height = window.innerHeight - 100;
            
            // Redraw based on chart type
            switch(originalId) {
                case 'goals-chart':
                    updateGoalsChart(data, fullscreenId, width, height);
                    break;
                case 'length-chart':
                    updateLengthChart(data, fullscreenId, width, height);
                    break;
                case 'scatter-chart':
                    updateScatterChart(data, fullscreenId, width, height);
                    break;
                case 'conflict-network-chart':
                    updateNetworkChart(data, fullscreenId, width, height);
                    break;
                case 'goal-network-chart':
                    updateGoalNetworkChart(data, fullscreenId, width, height);
                    break;
            }
        }

        function fetchResults() {
            console.log('fetchResults called');
            fetch('/list_results')
                .then(res => res.json())
                .then(results => {
                    console.log('Results received:', results);
                    availableResults = results;
                    const selector = document.getElementById('result-selector');
                    selector.innerHTML = '';
                    
                    if (results.length === 0) {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'No results available';
                        selector.appendChild(option);
                        return;
                    }
                    
                    results.forEach(result => {
                        const option = document.createElement('option');
                        option.value = result.name;
                        option.textContent = `${result.name} (${result.modified})`;
                        selector.appendChild(option);
                    });
                    
                    // Auto-load the first (most recent) result
                    if (results.length > 0) {
                        console.log('Auto-loading first result:', results[0].name);
                        selector.value = results[0].name;
                        loadResult();
                    }
                })
                .catch(err => {
                    console.error('Error fetching results:', err);
                });
        }

        function loadResult() {
            const selector = document.getElementById('result-selector');
            const selectedResult = selector.value;
            
            console.log('loadResult called with:', selectedResult);
            
            if (!selectedResult) {
                alert('Please select a result to load');
                return;
            }
            
            fetch(`/preview_result?name=${encodeURIComponent(selectedResult)}`)
                .then(res => res.json())
                .then(result => {
                    console.log('Data loaded successfully, books count:', result.books ? result.books.length : 'no books');
                    data = result;
                    updateVisualization();
                })
                .catch(err => {
                    console.error('Error loading result:', err);
                    alert('Error loading result');
                });
        }

        function updateVisualization() {
            if (!data) return;
            
            updateStatsContainer();
            updateGoalsChart();
            updateLengthChart();
            updateScatterChart();
            updateNetworkChart();
            updateGoalNetworkChart();
            updateSceneSelector();
            setupEventListeners();
        }

        function updateStatsContainer() {
            const container = document.getElementById('stats-container');
            container.innerHTML = '';
            
            if (!data || !data.books) return;
            
            // Calculate statistics from nested data
            let totalScenes = 0;
            let totalGoals = 0;
            let totalConflicts = 0;
            const characters = new Set();
            
            data.books.forEach(book => {
                if (book.scenes) {
                    totalScenes += book.scenes.length;
                }
                if (book.goals) {
                    totalGoals += book.goals.length;
                    book.goals.forEach(goal => {
                        if (goal.character) characters.add(goal.character);
                    });
                }
                if (book.conflicts) {
                    totalConflicts += book.conflicts.length;
                    book.conflicts.forEach(conflict => {
                        if (conflict.character1) characters.add(conflict.character1);
                        if (conflict.character2) characters.add(conflict.character2);
                    });
                }
            });
            
            const stats = [
                { label: 'Books', value: data.books.length },
                { label: 'Scenes', value: totalScenes },
                { label: 'Goals', value: totalGoals },
                { label: 'Conflicts', value: totalConflicts },
                { label: 'Characters', value: characters.size }
            ];
            
            stats.forEach(stat => {
                const card = document.createElement('div');
                card.className = 'stat-card';
                card.innerHTML = `
                    <span class="stat-value">${stat.value.toLocaleString()}</span>
                    <span class="stat-label">${stat.label}</span>
                `;
                container.appendChild(card);
            });
        }

        function updateGoalsChart(chartData = data, containerId = 'goals-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; // Clear previous content
            
            if (!chartData || !chartData.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goals data available</div>';
                return;
            }

            // Aggregate goals by category across all books
            const goalCategories = {};
            
            chartData.books.forEach(book => {
                if (book.goals) {
                    book.goals.forEach(goal => {
                        if (goal.category) {
                            goalCategories[goal.category] = (goalCategories[goal.category] || 0) + 1;
                        }
                    });
                }
            });

            const chartWidth = width;
            const chartHeight = height;
            const margin = { top: 20, right: 20, bottom: 40, left: 80 };

            const svg = d3.select(container)
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight);

            // Prepare data for bar chart
            const categoryData = Object.entries(goalCategories)
                .map(([category, count]) => ({ category, count }))
                .sort((a, b) => b.count - a.count);

            if (categoryData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goal categories found</div>';
                return;
            }

            // Scales
            const xScale = d3.scaleLinear()
                .domain([0, d3.max(categoryData, d => d.count)])
                .range([margin.left, chartWidth - margin.right]);

            const yScale = d3.scaleBand()
                .domain(categoryData.map(d => d.category))
                .range([margin.top, chartHeight - margin.bottom])
                .padding(0.1);

            const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

            // Add bars
            svg.selectAll('rect')
                .data(categoryData)
                .enter()
                .append('rect')
                .attr('x', margin.left)
                .attr('y', d => yScale(d.category))
                .attr('width', d => xScale(d.count) - margin.left)
                .attr('height', yScale.bandwidth())
                .attr('fill', (d, i) => colorScale(i))
                .attr('stroke', '#ff69b4')
                .attr('stroke-width', 1);

            // Add labels
            svg.selectAll('.bar-label')
                .data(categoryData)
                .enter()
                .append('text')
                .attr('class', 'bar-label')
                .attr('x', d => xScale(d.count) + 5)
                .attr('y', d => yScale(d.category) + yScale.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('font-size', '12px')
                .attr('fill', '#00ffff')
                .text(d => d.count);

            // Add category labels
            svg.selectAll('.category-label')
                .data(categoryData)
                .enter()
                .append('text')
                .attr('class', 'category-label')
                .attr('x', margin.left - 10)
                .attr('y', d => yScale(d.category) + yScale.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('font-size', '11px')
                .attr('fill', '#00ffff')
                .attr('text-anchor', 'end')
                .text(d => d.category);

            // Add title
            svg.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('font-weight', 'bold')
                .attr('fill', '#00ffff')
                .text('Goal Categories Distribution');
        }

        function updateLengthChart(chartData = data, containerId = 'length-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (!chartData || !chartData.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No scene data available</div>';
                return;
            }

            // Collect scene lengths from all books
            const sceneLengths = [];
            chartData.books.forEach(book => {
                if (book.scenes) {
                    book.scenes.forEach(scene => {
                        if (scene.text) {
                            sceneLengths.push(scene.text.length);
                        }
                    });
                }
            });

            if (sceneLengths.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No scene text data found</div>';
                return;
            }

            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const chartWidth = width;
            const chartHeight = height;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', chartWidth)
                .attr('height', chartHeight);

            // Create histogram
            const bins = d3.histogram()
                .domain(d3.extent(sceneLengths))
                .thresholds(10)(sceneLengths);

            const xScale = d3.scaleLinear()
                .domain(d3.extent(sceneLengths))
                .range([margin.left, chartWidth - margin.right]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .range([chartHeight - margin.bottom, margin.top]);

            // Add bars
            svg.selectAll('rect')
                .data(bins)
                .enter()
                .append('rect')
                .attr('x', d => xScale(d.x0))
                .attr('y', d => yScale(d.length))
                .attr('width', d => Math.max(0, xScale(d.x1) - xScale(d.x0) - 1))
                .attr('height', d => chartHeight - margin.bottom - yScale(d.length))
                .attr('fill', '#ff69b4')
                .attr('stroke', '#00ffff')
                .attr('stroke-width', 1);

            // Add title
            svg.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', 15)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('fill', '#00ffff')
                .text('Scene Length Distribution');
        }

        function updateScatterChart(chartData = data, containerId = 'scatter-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            if (!chartData || !chartData.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No scene data available</div>';
                return;
            }

            // Collect data points from all books and aggregate by scene
            const sceneData = [];
            const sceneMap = new Map(); // To aggregate goals and conflicts by scene
            
            chartData.books.forEach(book => {
                // First, initialize scenes with basic info
                if (book.scenes) {
                    book.scenes.forEach(scene => {
                        sceneMap.set(scene.scene_id, {
                            scene_id: scene.scene_id,
                            book_title: book.book_title || 'Unknown',
                            scene_num: scene.scene_num || 0,
                            chapter_num: scene.chapter_num || 0,
                            text_length: scene.text ? scene.text.length : 0,
                            goals: 0,
                            conflicts: 0
                        });
                    });
                }
                
                // Count goals for each scene
                if (book.goals) {
                    book.goals.forEach(goal => {
                        if (goal.scene_id && sceneMap.has(goal.scene_id)) {
                            sceneMap.get(goal.scene_id).goals++;
                        }
                    });
                }
                
                // Count conflicts for each scene
                if (book.conflicts) {
                    book.conflicts.forEach(conflict => {
                        if (conflict.scene_id && sceneMap.has(conflict.scene_id)) {
                            sceneMap.get(conflict.scene_id).conflicts++;
                        }
                    });
                }
            });
            
            // Convert map to array for visualization
            sceneData.push(...sceneMap.values());

            console.log('Scatter plot data points:', sceneData.length);

            if (sceneData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No scene data found</div>';
                return;
            }

            // Add zoom/pan controls
            const controlsDiv = d3.select(container)
                .append('div')
                .style('margin-bottom', '10px')
                .style('text-align', 'center');

            controlsDiv.append('button')
                .text('Reset Zoom')
                .style('background', 'rgba(0,255,255,0.2)')
                .style('border', '1px solid #00ffff')
                .style('color', '#00ffff')
                .style('padding', '2px 6px')
                .style('margin', '0 5px')
                .style('font-family', 'VT323, monospace')
                .style('cursor', 'pointer')
                .on('click', resetZoom);

            controlsDiv.append('span')
                .style('color', '#00ffff')
                .style('font-family', 'VT323, monospace')
                .style('font-size', '12px')
                .style('margin', '0 10px')
                .text('Mouse: drag to pan, wheel to zoom');

            const margin = { top: 40, right: 20, bottom: 60, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.5, 10])
                .on('zoom', zoomed);

            svg.call(zoom);

            const xScale = d3.scaleLinear()
                .domain([0, d3.max(sceneData, d => d.goals) || 1])
                .range([0, chartWidth]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(sceneData, d => d.conflicts) || 1])
                .range([chartHeight, 0]);

            // Create chart group that will be transformed by zoom
            const chartGroup = g.append('g');

            // Add dots (smaller size)
            const dots = chartGroup.selectAll('.dot')
                .data(sceneData)
                .enter().append('circle')
                .attr('class', 'dot')
                .attr('cx', d => xScale(d.goals))
                .attr('cy', d => yScale(d.conflicts))
                .attr('r', d => Math.max(1.5, Math.min(4, Math.sqrt(d.text_length / 2000)))) // Smaller nodes
                .style('fill', '#ff69b4')
                .style('stroke', '#00ffff')
                .style('stroke-width', 0.5)
                .style('opacity', 0.7);

            // Add tooltips
            dots.append('title')
                .text(d => `${d.book_title} - Ch${d.chapter_num} Scene${d.scene_num}\nGoals: ${d.goals}, Conflicts: ${d.conflicts}\nText length: ${d.text_length}`);

            // Add axes
            const xAxis = g.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .style('fill', '#00ffff')
                .style('font-family', 'VT323, monospace');

            const yAxis = g.append('g')
                .attr('class', 'y-axis')
                .call(d3.axisLeft(yScale))
                .selectAll('text')
                .style('fill', '#00ffff')
                .style('font-family', 'VT323, monospace');

            // Add axis labels
            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (chartHeight / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('fill', '#00ffff')
                .style('font-family', 'VT323, monospace')
                .text('Number of Conflicts');

            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', chartHeight + margin.bottom - 10)
                .attr('text-anchor', 'middle')
                .style('fill', '#00ffff')
                .style('font-family', 'VT323, monospace')
                .text('Number of Goals');

            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 20)
                .attr('text-anchor', 'middle')
                .style('fill', '#ff69b4')
                .style('font-family', 'VT323, monospace')
                .style('font-size', '16px')
                .text(`Goals vs Conflicts by Scene (${sceneData.length} scenes)`);

            function zoomed(event) {
                const transform = event.transform;
                chartGroup.attr('transform', transform);
                
                // Update axes with new scale
                g.select('.x-axis').call(d3.axisBottom(transform.rescaleX(xScale)));
                g.select('.y-axis').call(d3.axisLeft(transform.rescaleY(yScale)));
            }

            function resetZoom() {
                svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
            }
        }

        function updateNetworkChart(chartData = data, containerId = 'conflict-network-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            console.log('updateNetworkChart called with:', chartData ? 'data exists' : 'no data');
            console.log('Books available:', chartData && chartData.books ? chartData.books.length : 'none');
            
            if (!chartData || !chartData.books) {
                console.log('No book data available for network');
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No book data available for network</div>';
                return;
            }

            // Collect conflict data
            const conflictData = {};
            let totalConflicts = 0;
            
            chartData.books.forEach(book => {
                if (book.conflicts) {
                    book.conflicts.forEach(conflict => {
                        totalConflicts++;
                        const type = conflict.conflict_type || 'unknown';
                        const severity = conflict.severity || 'medium';
                        
                        if (!conflictData[type]) {
                            conflictData[type] = { low: 0, medium: 0, high: 0 };
                        }
                        conflictData[type][severity]++;
                    });
                }
            });
            
            console.log('Total conflicts found:', totalConflicts);
            console.log('Conflict data:', conflictData);
            
            // Create D3 visualization
            const margin = { top: 40, right: 20, bottom: 80, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Prepare data for stacked bar chart
            const types = Object.keys(conflictData);
            const severities = ['low', 'medium', 'high'];
            const colors = { low: '#00ff00', medium: '#ffff00', high: '#ff6600' };
            
            const stackData = types.map(type => {
                const base = { type: type };
                let cumulative = 0;
                severities.forEach(severity => {
                    base[severity] = conflictData[type][severity];
                    base[severity + '_start'] = cumulative;
                    cumulative += conflictData[type][severity];
                });
                base.total = cumulative;
                return base;
            });

            const xScale = d3.scaleBand()
                .domain(types)
                .range([0, chartWidth])
                .padding(0.1);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(stackData, d => d.total)])
                .range([chartHeight, 0]);

            // Draw stacked bars
            severities.forEach(severity => {
                g.selectAll(`.bar-${severity}`)
                    .data(stackData)
                    .enter().append('rect')
                    .attr('class', `bar-${severity}`)
                    .attr('x', d => xScale(d.type))
                    .attr('width', xScale.bandwidth())
                    .attr('y', d => yScale(d[severity + '_start'] + d[severity]))
                    .attr('height', d => yScale(d[severity + '_start']) - yScale(d[severity + '_start'] + d[severity]))
                    .style('fill', colors[severity])
                    .style('opacity', 0.8)
                    .append('title')
                    .text(d => `${severity}: ${d[severity]} conflicts`);
            });

            // Add axes
            g.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .style('fill', '#00ffff')
                .style('font-family', 'VT323, monospace')
                .attr('transform', 'rotate(-45)')
                .style('text-anchor', 'end');

            g.append('g')
                .call(d3.axisLeft(yScale))
                .selectAll('text')
                .style('fill', '#00ffff')
                .style('font-family', 'VT323, monospace');

            // Add labels
            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (chartHeight / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('fill', '#00ffff')
                .style('font-family', 'VT323, monospace')
                .text('Number of Conflicts');

            g.append('text')
                .attr('x', chartWidth / 2)
                .attr('y', 0 - (margin.top / 2))
                .attr('text-anchor', 'middle')
                .style('fill', '#ff69b4')
                .style('font-family', 'VT323, monospace')
                .style('font-size', '16px')
                .text(`Conflicts by Type & Severity (${totalConflicts} total)`);

            // Add legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width - 100}, 30)`);

            severities.forEach((severity, i) => {
                const legendRow = legend.append('g')
                    .attr('transform', `translate(0, ${i * 20})`);

                legendRow.append('rect')
                    .attr('width', 15)
                    .attr('height', 15)
                    .style('fill', colors[severity]);

                legendRow.append('text')
                    .attr('x', 20)
                    .attr('y', 12)
                    .style('fill', '#00ffff')
                    .style('font-family', 'VT323, monospace')
                    .style('font-size', '12px')
                    .text(severity);
            });
        }

        function updateGoalNetworkChart(chartData = data, containerId = 'goal-network-chart', width = 450, height = 300) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            console.log('updateGoalNetworkChart called with:', chartData ? 'data exists' : 'no data');
            
            if (!chartData || !chartData.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No goal data available</div>';
                return;
            }

            const nodes = [];
            const links = [];
            const characterGoalCounts = {};
            const goalCategoryCounts = {};
            const characterConflicts = {};

            // First pass: Collect all data
            chartData.books.forEach(book => {
                // Count goals by character and category
                if (book.goals) {
                    book.goals.forEach(goal => {
                        if (goal.character && goal.category) {
                            // Count character-goal relationships
                            if (!characterGoalCounts[goal.character]) {
                                characterGoalCounts[goal.character] = {};
                            }
                            characterGoalCounts[goal.character][goal.category] = 
                                (characterGoalCounts[goal.character][goal.category] || 0) + 1;
                            
                            // Count goal categories
                            goalCategoryCounts[goal.category] = (goalCategoryCounts[goal.category] || 0) + 1;
                        }
                    });
                }

                // Count character conflicts
                if (book.conflicts) {
                    book.conflicts.forEach(conflict => {
                        // Extract characters from description if characters_involved is empty
                        let characters = [];
                        if (conflict.characters_involved && conflict.characters_involved.length > 0) {
                            characters = conflict.characters_involved;
                        } else if (conflict.description) {
                            // Try to extract character names from the description
                            const description = conflict.description;
                            Object.keys(characterGoalCounts).forEach(char => {
                                if (description.includes(char)) {
                                    characters.push(char);
                                }
                            });
                        }

                        // Create conflict pairs
                        for (let i = 0; i < characters.length; i++) {
                            for (let j = i + 1; j < characters.length; j++) {
                                const char1 = characters[i];
                                const char2 = characters[j];
                                const pair = [char1, char2].sort().join('|||');
                                characterConflicts[pair] = (characterConflicts[pair] || 0) + 1;
                            }
                        }
                    });
                }
            });

            const filterCategory = document.getElementById('goal-filter')?.value || 'all';

            // Create character nodes (sized by total goals)
            Object.keys(characterGoalCounts).forEach(char => {
                const totalGoals = Object.values(characterGoalCounts[char]).reduce((sum, count) => sum + count, 0);
                nodes.push({
                    id: char,
                    type: 'character',
                    name: char.length > 15 ? char.substring(0, 15) + '...' : char,
                    size: Math.max(8, Math.min(20, 8 + totalGoals * 2)), // Scale based on goal count
                    goalCount: totalGoals
                });
            });

            // Create goal category nodes (sized by frequency)
            Object.entries(goalCategoryCounts).forEach(([category, count]) => {
                if (filterCategory === 'all' || filterCategory === category) {
                    nodes.push({
                        id: category,
                        type: 'goal',
                        name: category.length > 15 ? category.substring(0, 15) + '...' : category,
                        size: Math.max(6, Math.min(25, 6 + count * 0.5)), // Scale based on frequency
                        goalCount: count
                    });
                }
            });

            // Create character-goal links
            Object.entries(characterGoalCounts).forEach(([char, goals]) => {
                Object.entries(goals).forEach(([category, count]) => {
                    if (filterCategory === 'all' || filterCategory === category) {
                        links.push({
                            source: char,
                            target: category,
                            type: 'goal',
                            strength: Math.min(5, count * 0.5), // Thicker for more goals
                            count: count
                        });
                    }
                });
            });

            // Create character-character conflict links
            Object.entries(characterConflicts).forEach(([pair, count]) => {
                const [char1, char2] = pair.split('|||');
                if (characterGoalCounts[char1] && characterGoalCounts[char2]) {
                    links.push({
                        source: char1,
                        target: char2,
                        type: 'conflict',
                        strength: Math.min(8, count), // Thicker for more conflicts
                        count: count
                    });
                }
            });

            if (nodes.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">No character-goal relationships found</div>';
                return;
            }

            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            // Add zoom behavior
            const g = svg.append('g');

            const zoom = d3.zoom()
                .scaleExtent([0.2, 4])
                .on('zoom', function(event) {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            // Add reset zoom button
            const resetBtn = svg.append('text')
                .attr('x', width - 80)
                .attr('y', 15)
                .text('Reset View')
                .style('fill', '#00ffff')
                .style('font-family', 'VT323, monospace')
                .style('font-size', '12px')
                .style('cursor', 'pointer')
                .on('click', function() {
                    svg.transition().duration(750).call(
                        zoom.transform,
                        d3.zoomIdentity
                    );
                });

            // Add legend
            const legend = svg.append('g')
                .attr('transform', 'translate(10, 20)');

            legend.append('circle')
                .attr('cx', 10)
                .attr('cy', 10)
                .attr('r', 8)
                .style('fill', '#ff69b4');
            
            legend.append('text')
                .attr('x', 25)
                .attr('y', 15)
                .text('Characters')
                .style('fill', '#ffffff')
                .style('font-family', 'VT323, monospace')
                .style('font-size', '11px');

            legend.append('circle')
                .attr('cx', 10)
                .attr('cy', 30)
                .attr('r', 6)
                .style('fill', '#00ffff');
            
            legend.append('text')
                .attr('x', 25)
                .attr('y', 35)
                .text('Goal Types')
                .style('fill', '#ffffff')
                .style('font-family', 'VT323, monospace')
                .style('font-size', '11px');

            legend.append('line')
                .attr('x1', 5)
                .attr('y1', 50)
                .attr('x2', 20)
                .attr('y2', 50)
                .style('stroke', '#00ffff')
                .style('stroke-width', 2);
            
            legend.append('text')
                .attr('x', 25)
                .attr('y', 55)
                .text('Has Goals')
                .style('fill', '#ffffff')
                .style('font-family', 'VT323, monospace')
                .style('font-size', '11px');

            legend.append('line')
                .attr('x1', 5)
                .attr('y1', 70)
                .attr('x2', 20)
                .attr('y2', 70)
                .style('stroke', '#ff4444')
                .style('stroke-width', 3);
            
            legend.append('text')
                .attr('x', 25)
                .attr('y', 75)
                .text('In Conflict')
                .style('fill', '#ffffff')
                .style('font-family', 'VT323, monospace')
                .style('font-size', '11px');

            const forceStrength = parseInt(document.getElementById('goal-force-slider')?.value || 150);

            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).strength(d => d.type === 'conflict' ? 0.8 : 0.3))
                .force('charge', d3.forceManyBody().strength(-forceStrength))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => d.size + 2));

            // Create links
            const link = g.append('g')
                .selectAll('line')
                .data(links)
                .enter().append('line')
                .style('stroke', d => d.type === 'conflict' ? '#ff4444' : '#00ffff')
                .style('stroke-opacity', d => d.type === 'conflict' ? 0.8 : 0.6)
                .style('stroke-width', d => d.strength)
                .style('stroke-dasharray', d => d.type === 'conflict' ? '0' : '2,2');

            // Create nodes
            const node = g.append('g')
                .selectAll('circle')
                .data(nodes)
                .enter().append('circle')
                .attr('r', d => d.size)
                .style('fill', d => d.type === 'character' ? '#ff69b4' : '#00ffff')
                .style('stroke', '#fff')
                .style('stroke-width', 2)
                .style('opacity', 0.8)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Add hover effects
            node.on('mouseover', function(event, d) {
                d3.select(this).style('opacity', 1).style('stroke-width', 3);
                
                // Highlight connected links
                link.style('opacity', function(l) {
                    return (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.3;
                });
            })
            .on('mouseout', function(event, d) {
                d3.select(this).style('opacity', 0.8).style('stroke-width', 2);
                link.style('opacity', l => l.type === 'conflict' ? 0.8 : 0.6);
            });

            // Create labels
            const label = g.append('g')
                .selectAll('text')
                .data(nodes)
                .enter().append('text')
                .text(d => d.name)
                .style('font-family', 'VT323, monospace')
                .style('font-size', '10px')
                .style('fill', '#ffffff')
                .style('text-anchor', 'middle')
                .style('pointer-events', 'none')
                .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)');

            // Update positions on simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y + 4);
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        function updateSceneSelector() {
            const selector = document.getElementById('scene-selector');
            selector.innerHTML = '<option value="">Choose a scene...</option>';
            
            if (!data || !data.books) return;
            
            // Add first scene from first book by default instead of all scenes
            if (data.books.length > 0 && data.books[0].scenes && data.books[0].scenes.length > 0) {
                const firstBook = data.books[0];
                const firstScene = firstBook.scenes[0];
                const option = document.createElement('option');
                option.value = `0-0`; // book index - scene index
                option.textContent = `${firstBook.title || 'Book 1'} - ${firstScene.title || 'Scene 1'}`;
                option.selected = true;
                selector.appendChild(option);
                
                // Load this scene immediately
                updateSceneDetails(`0-0`);
            }
            
            // Add all other scenes
            data.books.forEach((book, bookIndex) => {
                if (book.scenes) {
                    book.scenes.forEach((scene, sceneIndex) => {
                        if (bookIndex === 0 && sceneIndex === 0) return; // Skip first scene as it's already added
                        
                        const option = document.createElement('option');
                        option.value = `${bookIndex}-${sceneIndex}`;
                        option.textContent = `${book.title || `Book ${bookIndex + 1}`} - ${scene.title || `Scene ${sceneIndex + 1}`}`;
                        selector.appendChild(option);
                    });
                }
            });
        }

        function updateSceneDetails(sceneId) {
            const container = document.getElementById('scene-details');
            container.innerHTML = '';
            
            if (!sceneId || !data || !data.books) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #00ffff;">Select a scene to view details</div>';
                return;
            }
            
            const [bookIndex, sceneIndex] = sceneId.split('-').map(Number);
            const book = data.books[bookIndex];
            const scene = book?.scenes?.[sceneIndex];
            
            if (!scene) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #ff0000;">Scene not found</div>';
                return;
            }
            
            const sceneInfo = document.createElement('div');
            sceneInfo.className = 'scene-info';
            
            // Scene header
            const header = document.createElement('div');
            header.className = 'scene-header';
            header.textContent = `${book.title || `Book ${bookIndex + 1}`} - ${scene.title || `Scene ${sceneIndex + 1}`}`;
            sceneInfo.appendChild(header);
            
            // Scene metadata
            const meta = document.createElement('div');
            meta.className = 'scene-meta';
            meta.innerHTML = `
                <strong>Chapter:</strong> ${scene.chapter || 'Unknown'} | 
                <strong>Narrator:</strong> ${scene.narrator || 'Unknown'} |
                <strong>Length:</strong> ${scene.text ? scene.text.length.toLocaleString() + ' characters' : 'No text'}
            `;
            sceneInfo.appendChild(meta);
            
            // Goals section
            if (scene.goals && scene.goals.length > 0) {
                const goalsSection = document.createElement('div');
                goalsSection.className = 'goals-conflicts';
                goalsSection.innerHTML = '<h4>üéØ Goals:</h4>';
                
                scene.goals.forEach(goal => {
                    const goalDiv = document.createElement('div');
                    goalDiv.className = 'goal-item';
                    goalDiv.innerHTML = `
                        <strong>${goal.character || 'Unknown'}:</strong> ${goal.description || 'No description'}<br>
                        <small><em>Category: ${goal.category || 'Uncategorized'} | Type: ${goal.motivation_type || 'Unknown'}</em></small>
                    `;
                    goalsSection.appendChild(goalDiv);
                });
                
                sceneInfo.appendChild(goalsSection);
            }
            
            // Conflicts section
            if (scene.conflicts && scene.conflicts.length > 0) {
                const conflictsSection = document.createElement('div');
                conflictsSection.className = 'goals-conflicts';
                conflictsSection.innerHTML = '<h4>‚öîÔ∏è Conflicts:</h4>';
                
                scene.conflicts.forEach(conflict => {
                    const conflictDiv = document.createElement('div');
                    conflictDiv.className = 'conflict-item';
                    conflictDiv.innerHTML = `
                        <strong>${conflict.character1 || 'Unknown'} vs ${conflict.character2 || 'Unknown'}:</strong> ${conflict.description || 'No description'}<br>
                        <small><em>Type: ${conflict.type || 'Unknown'} | Intensity: ${conflict.intensity || 'Unknown'}</em></small>
                    `;
                    conflictsSection.appendChild(conflictDiv);
                });
                
                sceneInfo.appendChild(conflictsSection);
            }
            
            // Text preview
            if (scene.text) {
                const textPreview = document.createElement('div');
                textPreview.innerHTML = '<h4>üìñ Text Preview:</h4>';
                
                const textDiv = document.createElement('div');
                textDiv.className = 'evidence-text';
                // Show first 500 characters
                const previewText = scene.text.length > 500 ? 
                    scene.text.substring(0, 500) + '...' : 
                    scene.text;
                textDiv.textContent = previewText;
                textPreview.appendChild(textDiv);
                
                sceneInfo.appendChild(textPreview);
            }
            
            container.appendChild(sceneInfo);
        }

        function setupEventListeners() {
            // Scene selector
            const sceneSelector = document.getElementById('scene-selector');
            if (sceneSelector && !sceneSelector.hasAttribute('data-listeners-added')) {
                sceneSelector.addEventListener('change', (e) => updateSceneDetails(e.target.value));
                sceneSelector.setAttribute('data-listeners-added', 'true');
            }
            
            // Other controls...
            const goalSort = document.getElementById('goal-sort');
            if (goalSort && !goalSort.hasAttribute('data-listeners-added')) {
                goalSort.addEventListener('change', updateGoalsChart);
                goalSort.setAttribute('data-listeners-added', 'true');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('load-result').addEventListener('click', loadResult);
            fetchResults();
        });
    </script>
</body>
</html>
